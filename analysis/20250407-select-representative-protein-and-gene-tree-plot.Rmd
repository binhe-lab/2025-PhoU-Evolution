---
title: "20250407-select-representative-proteins"
author: "Bin He"
date: "2025-04-07 updated `r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
require(ggtree)
require(treeio)
require(seqinr)
require(tidyverse)
```

```{r}
# set plotting theme to theme_bw(base_size = 16) and save the current settings
# to `old`
old <- theme_set(theme_bw(base_size = 16))
```

## Goal
Select 100-300 representative proteins from each of the PhoU and PitR related proteins. We will use two criteria to select:
1. We have used `CD-HIT` to cluster both sets at 70% identity, which reduced each set to 1/4 of the original size. But this still left us ~8000 and ~5000 sequences in each set, respectively.
2. Using the above clustered sets as the starting point, we will next select proteins based on species.

## Data
Read in the protein sequences after clustering from the `../input/fasta-sequences` folder using `seqinr` and extract the sequence names.
```{r}
# read in the protein sequences after clustering
fasta_files <- list.files(path = "../data/fasta-sequences", 
                          pattern = "*-clustered.fa$", full.names = TRUE)
names(fasta_files) <- c("PitR", "PhoU", "NptA")
print(fasta_files) # double check that the names and files match
clustered_seqs <- map(fasta_files, \(f) read.fasta(f, seqtype = "AA"))
# extract the sequence names  
seq_names <- map(clustered_seqs, \(x) getName(x)) |>
  # split the names by | into three columns and bind the three lists as rows
  lapply(\(x) tibble(name = str_split(x, "\\|", simplify = TRUE)[,1])) |>
  list_rbind(names_to = "group")
```

Read in sequence information
```{r}
info_files <- list.files(path = "../data/fasta-sequences", 
                          pattern = "*-table.tsv.gz$", full.names = TRUE)
names(info_files) <- c("PitR", "PhoU", "NptA")
print(info_files) # double check that the names and files match
seq_info <- map(info_files, \(f) read_tsv(f, show_col_types = FALSE)) |>
  list_rbind(names_to = "group")
# filter the sequences to only include those in the clustered set
clustered_seq_info <- seq_info |>
  filter(Accession %in% seq_names$name) |>
  # split the `Tax Name` column into three, with the first column containing
  # the genus and the second the species, and the remaining going to the 
  # third column (typically strain or subspecies and other info)
  separate_wider_delim(`Tax Name`, delim = " ",
                        names = c("Genus", "Species", "Other"), 
                        too_few = "align_start", too_many = "merge")
```

Because we want to make sure that the _S. aureus_ sequences are included, we will keep them in a separate table and then merge them back in later.
```{r}
# identify the _S. aureus_ sequences
staph_aureus_unip_ids = c("PitR" = "A0A0H3K7D8", 
                          "PhoU" = "A0A0H3K808",
                          "NptA" = "A0A0H3K9X3")
```


## Select representative proteins
### For CLANS
Group by genus and select the first sequence in each group
```{r}
genus_representative <- clustered_seq_info |>
  distinct(group, Genus, .keep_all = TRUE)
count(genus_representative, group)
```

After both `CD-HIT` clustering and species filtering, we are left with 1k and 2k sequences in the PitR and PhoU sets. 

Now we will check if the _S. aureus_ representatives are in the list.
```{r}
# are they all in the list?
all(staph_aureus_unip_ids %in% genus_representative$Accession)
```

Good. Let's export the list of representative sequences to a tsv file.
```{r}
write_tsv(genus_representative, 
          file = "../data/fasta-sequences/20250417-representative-proteins.tsv")
```


Now, we will generate a filtered fasta file containing the genus representative sequences for the PhoU and PitR homologs only. When exporting, we will rename the sequences to the following format:
">Accession PhoU|PitR Genus_species CD-HIT_cluster_id"

First, we identify the selected sequence accessions and filter the sequence list.
```{r}
# merge the PitR and PhoU related sequences, leaving out NptA
grouped_seqs <- do.call(c, clustered_seqs[c("PitR", "PhoU")])

# Filter sequences: get only those whose name matches selected accessions
grouped_seqs_acc <- getName(grouped_seqs) |> str_split("\\|", simplify = TRUE)
grouped_seqs_acc <- grouped_seqs_acc[,1]
select_seqs_acc <- genus_representative |> filter(group != "NptA") |> pull(Accession)
selected_seqs <- grouped_seqs[which(grouped_seqs_acc %in% select_seqs_acc)]
sprintf("Selected %d sequences from %d total", length(selected_seqs), length(grouped_seqs))
```
Next, we rename the sequences
```{r}
# Convert list to a named character vector for renaming
new_names <- genus_representative |>
  filter(group != "NptA") |>
  mutate(new_name = paste(Accession, group, Genus, Species, sep = " ")) |>
  select(Accession, new_name) |>
  deframe()

# get the names of the selected sequences
selected_seqs_acc <- getName(selected_seqs) |> str_split("\\|", simplify = TRUE)
selected_seqs_acc <- selected_seqs_acc[,1]

# check to make sure that the selected sequences are in the new names
all(selected_seqs_acc %in% names(new_names))

# export the selected sequences to a fasta file
write.fasta(sequences = selected_seqs, 
            names = new_names[selected_seqs_acc], 
            file.out = "../data/fasta-sequences/20250417-representative-proteins.fa")
```

### For gene tree
We will randomly select 100 and 200 proteins from the PitR and PhoU sets, respectively. We will also include the _S. aureus_ sequences in the list.
```{r}
# randomly select 100 and 200 proteins from the PitR and PhoU sets, respectively
set.seed(20250407)
# PitR
pitr_representative <- clustered_seq_info |>
  filter(group == "PitR") |>
  filter(!Accession %in% staph_aureus_unip_ids) |>
  slice_sample(n = 100)
# PhoU
phou_representative <- clustered_seq_info |>
  filter(group == "PhoU") |>
  filter(!Accession %in% staph_aureus_unip_ids) |>
  slice_sample(n = 200)
# Combine the two with the S. aureus sequences
seq_for_tree <- bind_rows(
  pitr_representative, phou_representative,
  # add the _S. aureus_ sequences
  clustered_seq_info |>
    filter(Accession %in% staph_aureus_unip_ids)) |>
  # remove the NptA sequences
  filter(group != "NptA")
```

Write the selected sequences to a tsv file
```{r}
write_tsv(seq_for_tree, 
          file = "../data/fasta-sequences/20250425-select-proteins-for-tree.tsv")
```

Next, we will generate a filtered fasta file containing the selected sequences for the PhoU and PitR homologs only. When exporting, we will rename the sequences to the following format:
```{r}
# Filter sequences: get only those whose name matches selected accessions
tree_seqs_acc <- seq_for_tree$Accession
tree_seqs <- grouped_seqs[which(grouped_seqs_acc %in% tree_seqs_acc)]
sprintf("Selected %d sequences from %d total", length(tree_seqs), length(grouped_seqs))
```
Next, we rename the sequences
```{r}
# Convert list to a named character vector for renaming
new_names_tree <- seq_for_tree |>
  mutate(new_name = paste(Accession, group, Genus, Species, sep = " ")) |>
  select(Accession, new_name) |>
  deframe()

# get the names of the selected sequences
tree_seqs_acc <- getName(tree_seqs) |> str_split("\\|", simplify = TRUE)
tree_seqs_acc <- tree_seqs_acc[,1]

# check to make sure that the selected sequences are in the new names
all(tree_seqs_acc %in% names(new_names_tree))

# export the selected sequences to a fasta file
write.fasta(sequences = tree_seqs, 
            names = new_names_tree[tree_seqs_acc], 
            file.out = "../data/fasta-sequences/20250425-select-proteins-for-tree.fa")
```

To determine if the resulting gene tree pattern is robust to the choice of sequences, I will repeat the above sampling process to generate two more randomly sampled sequences and perform the same gene tree reconstruction for them.
```{r}
# repeat the sampling and exporting process for two more sets of sequences
# randomly select 100 and 200 proteins from the PitR and PhoU sets, respectively
set.seed(20250408)
# PitR
pitr_representative_2 <- clustered_seq_info |>
  filter(group == "PitR") |>
  filter(!Accession %in% staph_aureus_unip_ids) |>
  slice_sample(n = 100)
# PhoU
phou_representative_2 <- clustered_seq_info |>
  filter(group == "PhoU") |>
  filter(!Accession %in% staph_aureus_unip_ids) |>
  slice_sample(n = 200)
# Combine the two with the S. aureus sequences
seq_for_tree_2 <- bind_rows(
  pitr_representative_2, phou_representative_2,
  # add the _S. aureus_ sequences
  clustered_seq_info |>
    filter(Accession %in% staph_aureus_unip_ids)) |>
  # remove the NptA sequences
  filter(group != "NptA")
# Write the selected sequences to a tsv file
write_tsv(seq_for_tree_2, 
          file = "../data/fasta-sequences/20250425-select-proteins-for-tree-2.tsv")
# Filter sequences: get only those whose name matches selected accessions
tree_seqs_acc_2 <- seq_for_tree_2$Accession
tree_seqs_2 <- grouped_seqs[which(grouped_seqs_acc %in% tree_seqs_acc_2)]
sprintf("Selected %d sequences from %d total", length(tree_seqs_2), length(grouped_seqs))
# Convert list to a named character vector for renaming
new_names_tree_2 <- seq_for_tree_2 |>
  mutate(new_name = paste(Accession, group, Genus, Species, sep = " ")) |>
  select(Accession, new_name) |>
  deframe()

# get the names of the selected sequences
tree_seqs_acc_2 <- getName(tree_seqs_2) |> str_split("\\|", simplify = TRUE)
tree_seqs_acc_2 <- tree_seqs_acc_2[,1]

# check to make sure that the selected sequences are in the new names
all(tree_seqs_acc_2 %in% names(new_names_tree_2))
# export the selected sequences to a fasta file
write.fasta(sequences = tree_seqs_2, 
            names = new_names_tree_2[tree_seqs_acc_2], 
            file.out = "../data/fasta-sequences/20250425-select-proteins-for-tree-2.fa")
```
3rd set
```{r}
# repeat the sampling and exporting process for two more sets of sequences
# randomly select 100 and 200 proteins from the PitR and PhoU sets, respectively
set.seed(20250409)
# PitR
pitr_representative_3 <- clustered_seq_info |>
  filter(group == "PitR") |>
  filter(!Accession %in% staph_aureus_unip_ids) |>
  slice_sample(n = 100)
# PhoU
phou_representative_3 <- clustered_seq_info |>
  filter(group == "PhoU") |>
  filter(!Accession %in% staph_aureus_unip_ids) |>
  slice_sample(n = 200)
# Combine the two with the S. aureus sequences
seq_for_tree_3 <- bind_rows(
  pitr_representative_3, phou_representative_3,
  # add the _S. aureus_ sequences
  clustered_seq_info |>
    filter(Accession %in% staph_aureus_unip_ids)) |>
  # remove the NptA sequences
  filter(group != "NptA")
# Write the selected sequences to a tsv file
write_tsv(seq_for_tree_3, 
          file = "../data/fasta-sequences/20250425-select-proteins-for-tree-3.tsv")
# Filter sequences: get only those whose name matches selected accessions
tree_seqs_acc_3 <- seq_for_tree_3$Accession
tree_seqs_3 <- grouped_seqs[which(grouped_seqs_acc %in% tree_seqs_acc_3)]
sprintf("Selected %d sequences from %d total", length(tree_seqs_3), length(grouped_seqs))
# Convert list to a named character vector for renaming
new_names_tree_3 <- seq_for_tree_3 |>
  mutate(new_name = paste(Accession, group, Genus, Species, sep = " ")) |>
  select(Accession, new_name) |>
  deframe()

# get the names of the selected sequences
tree_seqs_acc_3 <- getName(tree_seqs_3) |> str_split("\\|", simplify = TRUE)
tree_seqs_acc_3 <- tree_seqs_acc_3[,1]

# check to make sure that the selected sequences are in the new names
all(tree_seqs_acc_3 %in% names(new_names_tree_3))
# export the selected sequences to a fasta file
write.fasta(sequences = tree_seqs_3, 
            names = new_names_tree_3[tree_seqs_acc_3], 
            file.out = "../data/fasta-sequences/20250425-select-proteins-for-tree-3.fa")
```


## Plot gene tree
The above selected protein sequences were aligned using MAFFT V7.526 with the E-INS-i algorithm optimized for divergent sequences with multiple conserved domains. I also tried MSAprobs and the result looked superficially similar.

Gene tree reconstruction was performed using RAXML v8.2.12 on the Galaxy server. I used "LG+G" as the protein substitution model and matrix. I chose the `-f` option to run a rapid bootstrap, but the result is not in the output. If we want the bootstrap values, I can get it by running the program locally.

### LG+G model
```{r}
gene_tree_LG1 <- read.tree("../output/gene-tree/20250426-PhoU-PitR-select-raxml-PROTGAMMA-LG-best-ML-tree.nwk") %>% 
  as_tibble() %>% 
  #mutate(label = gsub("_", " ", label)) %>% 
  left_join(seq_for_tree, by = c("label" = "Accession")) %>% 
  as.treedata()
```

plot the tree, with labels for the _S. aureus_ sequences
```{r}
ggtree(gene_tree_LG1, layout = "equal_angle") + #xlim(0,2.2) + scale_y_reverse() +
  geom_tiplab(aes(subset = label %in% c("A0A0H3K808", "A0A0H3K7D8"), 
                  angle = angle, label = paste("S. aureus", group, sep = " ")), 
              size = 3.5, geom = "label") +
  #geom_treescale(x = 0, width = 0.2, linesize = 1.2) +
  geom_tippoint(aes(color = group), size = 1.5) +
  scale_color_manual("Group", values =  c("PhoU" = "#6a5acd",
                                 "PitR" = "#d14949")) +
  #guides(color = guide_legend(byrow = TRUE)) +
  theme(legend.position = c(0.12, 0.13),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)))
ggsave("../output/gene-tree/20250426-PhoU-PitR-select-raxml-PROTGAMMA-LG-best-ML-tree.png", 
       width = 8, height = 8)
```

plot the tree, no labels for the _S. aureus_ sequences
```{r}
ggtree(gene_tree, layout = "equal_angle") + #xlim(0,2.2) + scale_y_reverse() +
  #geom_tiplab(aes(subset = label %in% c("A0A0H3K808", "A0A0H3K7D8"), 
  #                angle = angle, label = paste("S. aureus", group, sep = " ")), 
  #            size = 3.5, geom = "label") +
  #geom_treescale(x = 0, width = 0.2, linesize = 1.2) +
  geom_tippoint(aes(color = group), size = 1.5) +
  scale_color_manual("Group", values =  c("PhoU" = "#6a5acd",
                                 "PitR" = "#d14949")) +
  #guides(color = guide_legend(byrow = TRUE)) +
  theme(legend.position = c(0.12, 0.13),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)))
ggsave("../output/gene-tree/20250512-PhoU-PitR-select-raxml-PROTGAMMA-LG-best-ML-tree-no_label.png", 
       width = 8, height = 8)
```

### Dayhoff model
I made a second tree using `PROTCAT` as the model and `DAYHOFF` as the matrix. I'd like to see whether the result is robust to these choices.

```{r}
gene_tree_DH <- read.tree("../output/gene-tree/20250426-PhoU-PitR-select-raxml-PROTCAT-Dayhoff-best-ML-tree.nwk") %>% 
  as_tibble() %>% 
  #mutate(label = gsub("_", " ", label)) %>% 
  left_join(seq_for_tree, by = c("label" = "Accession")) %>% 
  as.treedata()
```

plot the tree, with labels for the _S. aureus_ sequences
```{r}
ggtree(gene_tree_DH, layout = "equal_angle") + #xlim(0,2.2) + scale_y_reverse() +
  geom_tiplab(aes(subset = label %in% c("A0A0H3K808", "A0A0H3K7D8"), 
                  angle = angle, label = paste("S. aureus", group, sep = " ")), 
              size = 3.5, geom = "label") +
  #geom_treescale(x = 0, width = 0.2, linesize = 1.2) +
  geom_tippoint(aes(color = group), size = 1.5) +
  scale_color_manual("Group", values =  c("PhoU" = "#6a5acd",
                                 "PitR" = "#d14949")) +
  #guides(color = guide_legend(byrow = TRUE)) +
  theme(legend.position = c(0.12, 0.13),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)))
ggsave("../output/gene-tree/20250426-PhoU-PitR-select-raxml-PROTCAT-Dayhoff-best-ML-tree.png", 
       width = 8, height = 8)
```

plot the tree, no labels
```{r}
ggtree(gene_tree_DH, layout = "equal_angle") + #xlim(0,2.2) + scale_y_reverse() +
  #geom_tiplab(aes(subset = label %in% c("A0A0H3K808", "A0A0H3K7D8"), 
  #                angle = angle, label = paste("S. aureus", group, sep = " ")), 
  #            size = 3.5, geom = "label") +
  #geom_treescale(x = 0, width = 0.2, linesize = 1.2) +
  geom_tippoint(aes(color = group), size = 1.5) +
  scale_color_manual("Group", values =  c("PhoU" = "#6a5acd",
                                 "PitR" = "#d14949")) +
  #guides(color = guide_legend(byrow = TRUE)) +
  theme(legend.position = c(0.12, 0.13),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)))
ggsave("../output/gene-tree/20250512-PhoU-PitR-select-raxml-PROTCAT-Dayhoff-best-ML-tree-no_label.png", 
       width = 8, height = 8)
```

### LG+G model, set 2
Read tree and add sequence information
```{r}
gene_tree_LG2 <- read.tree("../output/gene-tree/20250514-PhoU-PitR-select-raxml-PROTGAMMA-LG-best-ML-tree-2.nwk") %>% 
  as_tibble() %>% 
  #mutate(label = gsub("_", " ", label)) %>% 
  left_join(seq_for_tree_2, by = c("label" = "Accession")) %>% 
  as.treedata()
```

plot the tree, with labels for the _S. aureus_ sequences
```{r}
ggtree(gene_tree_LG2, layout = "equal_angle") + #xlim(0,2.2) + scale_y_reverse() +
  geom_tiplab(aes(subset = label %in% c("A0A0H3K808", "A0A0H3K7D8"), 
                  angle = angle, label = paste("S. aureus", group, sep = " ")), 
              size = 3.5, geom = "label") +
  #geom_treescale(x = 0, width = 0.2, linesize = 1.2) +
  geom_tippoint(aes(color = group), size = 1.5) +
  scale_color_manual("Group", values =  c("PhoU" = "#6a5acd",
                                 "PitR" = "#d14949")) +
  #guides(color = guide_legend(byrow = TRUE)) +
  theme(legend.position = c(0.12, 0.13),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)))
ggsave("../output/gene-tree/20250514-PhoU-PitR-select-raxml-PROTGAMMA-LG-best-ML-tree-2.png", 
       width = 8, height = 8)
```

### LG+G model, set 3
Read tree and add sequence information
```{r}
gene_tree_LG3 <- read.tree("../output/gene-tree/20250514-PhoU-PitR-select-raxml-PROTGAMMA-LG-best-ML-tree-3.nwk") %>% 
  as_tibble() %>% 
  #mutate(label = gsub("_", " ", label)) %>% 
  left_join(seq_for_tree_3, by = c("label" = "Accession")) %>% 
  as.treedata()
```

plot the tree, with labels for the _S. aureus_ sequences
```{r}
ggtree(gene_tree_LG3, layout = "equal_angle") + #xlim(0,2.2) + scale_y_reverse() +
  geom_tiplab(aes(subset = label %in% c("A0A0H3K808", "A0A0H3K7D8"), 
                  angle = angle, label = paste("S. aureus", group, sep = " ")), 
              size = 3.5, geom = "label") +
  #geom_treescale(x = 0, width = 0.2, linesize = 1.2) +
  geom_tippoint(aes(color = group), size = 1.5) +
  scale_color_manual("Group", values =  c("PhoU" = "#6a5acd",
                                 "PitR" = "#d14949")) +
  #guides(color = guide_legend(byrow = TRUE)) +
  theme(legend.position = c(0.12, 0.13),
        legend.title = element_text(size = rel(1.2)),
        legend.text = element_text(size = rel(1.2)))
ggsave("../output/gene-tree/20250514-PhoU-PitR-select-raxml-PROTGAMMA-LG-best-ML-tree-3.png", 
       width = 8, height = 8)
```